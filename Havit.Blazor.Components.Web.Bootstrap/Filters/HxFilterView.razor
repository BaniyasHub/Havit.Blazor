@namespace Havit.Blazor.Components.Web.Bootstrap
<CascadingValue Value="@filtersRegistration" Name="@FilterRegistrationCascadingValueName" IsFixed="true">
	<CascadingValue Value="@chipGeneratorsRegistration" Name="@ChipGeneratorRegistrationCascadingValueName" IsFixed="true">
		@*Aby se dostaly komponenty do kolekcí, musíme je dostat do renderování této komponenty. Chceme však, aby komponenty nic nevyrenderovaly. *@
		@*Problémem však je aktualizace. V případě změny parametrů, dojde k přerenderování zde kritérií, protože v nich jsou filtry, od těch však očekáváme,
			že jsou prázdné a ve skutečnosti nic nerenderují.

			Nedojde tak k přerenderování dynamicky renderovaných hodnot (filter.GetLabelTemplate(), filter.GetFilterTemplate()).
			Využijeme tedy triku, kdy při vyrendrování hodnoty přes Criteria si vyvoláme událost filter.Rendered a v obsluze této události vyvoláme
			přerenderování zavolámím StateHasChanged. To musíme udělat v jiné komponentě než zde, jinak by došlo k zacyklení
			(StateHasChanged -> renderování @Criteria -> Rendered -> StateHasChanged -> renderování Criteria ...).

			Extrakce do komponenty má výhodu, že dojde k přerenderování jen nezbytně nutné části (nezbytně nutného filtru, rozlišení jeho LabelTemplate a FilterTemplate se neřeší).
		*@
		@Criteria
	</CascadingValue>
</CascadingValue>

@if (IsExpanded)
{
	<div class="d-flex flex-column flex-grow-1">
		@foreach (var filter in filters)
		{
			<span><UpdatedContentRenderer Component="@filter" ChildContent="@filter.GetLabelTemplate()" /></span>
			<span><UpdatedContentRenderer Component="@filter" ChildContent="@filter.GetFilterTemplate()" /></span>
		}
		<HxSubmit OnClick="ApplyFilterClick">Apply filter</HxSubmit> @*TODO:  Lokalizace*@
	</div>
}
else
{
	<HxChipList Chips="@chipGenerators.SelectMany(item => item.GetChips())" />
}